#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "courier" "default"
\font_math "newtxmath" "auto"
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype true
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 20page%
\topmargin 7pheight%
\rightmargin 20page%
\bottommargin 7pheight%
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Algorithms For Graph Structures
\end_layout

\begin_layout Author
Martin Janda
\end_layout

\begin_layout Paragraph*
Prague College
\end_layout

\begin_layout Paragraph*
Algorithms and Data Structures (FT)
\end_layout

\begin_layout Paragraph*
Dominik Pantůček
\end_layout

\begin_layout Paragraph*
Shortest Route(s)
\end_layout

\begin_layout Paragraph*
ICA2
\end_layout

\begin_layout Paragraph*
3676 Words
\end_layout

\begin_layout Paragraph*
Semester 2001
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Scenario
\end_layout

\begin_layout Paragraph*
The assignment provides a set of vertices (cities or road crossings in the
 E.U.) and a set of edges (major E.U.
 roads) as commands meant to be passed to an application program interface
 designed by the student.
 The student was given two cities and asked to code an algorithm in Clojure
 that was capable of finding the shortest path (or proving one does not
 exist) between each city and Prague.
 The student was given 
\begin_inset Quotes eld
\end_inset

Nuremberg
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Palmero
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Aim
\end_layout

\begin_layout Paragraph*
The aim of this assignment is to describe the most efficient implementation
 of the algorithms specified by the assignment brief.
 This technical report also addresses the graph and helper structures that
 have been implemented as they are a large part of the code being submitted
 and contribute directly to the efficiency of the algorithms.
 All code in this document was written by the author in Clojure a list processin
g programming language.
\end_layout

\begin_layout Section
Definitions
\end_layout

\begin_layout Itemize
Graph: A set of vertices and edges.
\end_layout

\begin_layout Itemize
Sparse (graph): A graph that has less then v
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 edges, where 
\begin_inset Quotes eld
\end_inset

v
\begin_inset Quotes erd
\end_inset

 is the number of vertices.
\end_layout

\begin_layout Itemize
Path: A sequence of vertices connected by edges.
 (Pantůček, 2020)
\end_layout

\begin_layout Itemize
Cycle: A path that begins and ends on the same vertex.
\end_layout

\begin_layout Itemize
Tree: A form of graph that contains no cycles.
\end_layout

\begin_layout Section
Prerequisite Structures and Functions
\end_layout

\begin_layout Paragraph*
The following are descriptions of major structures and functions that were
 implemented in order to create an efficient interface between implemented
 algorithms and the data supplied by the assignment.
\end_layout

\begin_layout Subsection
Data Structures
\end_layout

\begin_layout Paragraph*
This subsection addresses the underlying record structures of the implementation.
 Words on the efficiency of and justifications for these structures are
 in subsection 4.2.
\end_layout

\begin_layout Subsubsection
Red-Black Trees
\end_layout

\begin_layout Paragraph*
The data structure used for the open-queue in this implementation is a red-black
 tree.
 A red-black tree is a self balancing form of a binary search tree.
 The red-black tree is is defined by the following code, a reference to
 the root node of the tree.
\end_layout

\begin_layout Paragraph*
lyx is shit
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defrecord Red-Black-Tree [root])
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The root of the tree is a reference to a node.
 Tree nodes are defined by the code below and keep track of the following:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

label
\begin_inset Quotes erd
\end_inset

: the label of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

: the value by which the node is sorted.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

value2
\begin_inset Quotes erd
\end_inset

: the second value used to store distance from finish when 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 is used for great circle distance in A*.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

color
\begin_inset Quotes erd
\end_inset

: reference to the color of the node, either red or black, used to keep
 the tree balanced by related functions.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

: reference to the node that is to the left of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

: reference to the node that is to the right of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

parent
\begin_inset Quotes erd
\end_inset

: reference to the parent of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

child
\begin_inset Quotes erd
\end_inset

: reference to the value of which child the node is of its parent (left,
 right, root).
\end_layout

\begin_layout Paragraph*
lyx is shit
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defrecord Red-Black-Node [label value value2 color left right parent child])
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hash Maps
\end_layout

\begin_layout Paragraph*
Clojure's built in hash map data structure is used to store all the nodes
 and vertices of the graph.
 The graph itself is a record that contains references to two hash maps,
 one for the vertices and one for the edges.
\end_layout

\begin_layout Paragraph*
lyx is shit
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defrecord Graph [vertices edges])
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Adding Data
\end_layout

\begin_layout Paragraph*
When adding nodes to the open-queue the function 
\begin_inset Quotes eld
\end_inset

node-insert!
\begin_inset Quotes erd
\end_inset

 is called.
\end_layout

\begin_layout Paragraph*
lyx is shit
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn node-insert! [tree label value]
\end_layout

\begin_layout Plain Layout

  (if (red-black-tree-empty? tree)
\end_layout

\begin_layout Plain Layout

    (dosync
\end_layout

\begin_layout Plain Layout

      (ref-set (:root tree)
\end_layout

\begin_layout Plain Layout

       (make-node! label value Black nil Root)))
\end_layout

\begin_layout Plain Layout

    (cond
\end_layout

\begin_layout Plain Layout

     (< value @(:value @(:root tree)))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:left @(:root tree)) (:root tree) label value
 Left)
\end_layout

\begin_layout Plain Layout

      (> value @(:value @(:root tree)))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:right @(:root tree)) (:root tree) label value
 Right)
\end_layout

\begin_layout Plain Layout

      (= value @(:value @(:root tree)))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:right @(:root tree)) (:root tree) label value
 Right))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn node-insert-helper! [node parent label value child]
\end_layout

\begin_layout Plain Layout

  (if (tree-node-empty? node)
\end_layout

\begin_layout Plain Layout

    (do
\end_layout

\begin_layout Plain Layout

      (dosync
\end_layout

\begin_layout Plain Layout

        (ref-set node
\end_layout

\begin_layout Plain Layout

          (make-node! label value Red @parent child)))
\end_layout

\begin_layout Plain Layout

      (red-black-rules-checker! node))
\end_layout

\begin_layout Plain Layout

    (cond
\end_layout

\begin_layout Plain Layout

      (< value @(:value @node))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:left @node) node label value Left)
\end_layout

\begin_layout Plain Layout

      (> value @(:value @node))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:right @node) node label value Right)
\end_layout

\begin_layout Plain Layout

      (= value @(:value @node))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:right @node) node label value Right))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
These functions follow the standard procedure for inserting a node into
 a binary search tree.
 If the node being inserted is not the root of the red-black tree the 
\begin_inset Quotes eld
\end_inset

node-insert-helper!
\begin_inset Quotes erd
\end_inset

 function is called and it runs the 
\begin_inset Quotes eld
\end_inset

red-black-rules-checker!
\begin_inset Quotes erd
\end_inset

 function after the insertion.
 The 
\begin_inset Quotes eld
\end_inset

red-black-rules-checker!
\begin_inset Quotes erd
\end_inset

 function checks if the tree is still a red-black tree and performs all
 necessary rotations and color changes necessary to balance and restore
 its state.
\end_layout

\begin_layout Subsection
Justification
\end_layout

\begin_layout Paragraph*
Using a red-black tree has a number of benefits.
 Using a list for the open-queue in breadth first search his not optimal.
 In Clojure lists are single-linked which means that the head of the list
 contains a reference to only the first node and nodes only contain a reference
 to the next node and not the previous.
 This means that appending to the list would have a tightly bound linear
 time complexity O(n)= Ω(n)=Θ(n).
 Furthermore accessing the node with the lowest value would have a time
 complexity of O(n) and for the best case scenario Ω(1), as the list is
 not sorted.
\end_layout

\begin_layout Paragraph*
The red-black tree solves this problem as it is a form of a binary search
 tree.
 The tree is sorted and thus accessing the node with the lowest value is
 as simple as going to the left-most node of the tree.
 The time complexity of this is tightly bound O(log n)= Ω(log n)=Θ(log n)
 and the memory complexity is constant.
 For insertions the time complexity is not tightly bound O(log n) and Ω(1)
 if the tree is empty.
 This logarithmic time complexity is due to the maximum height of any red-black
 tree which is O(log n) thanks to the self balancing nature of the tree.
 
\end_layout

\begin_layout Paragraph*
It was considered that the entire graph structure could be represented using
 red-black trees.
 However, the efficiency of this could not be justified as Clojure has a
 hash map structure that has a near constant time complexity for accessing
 and inserting nodes.
\end_layout

\begin_layout Section
Indexing Connected Components
\end_layout

\begin_layout Paragraph*
In each vertex record structure is as 
\begin_inset Quotes eld
\end_inset

component
\begin_inset Quotes erd
\end_inset

 value.
 This value is used to tell whether any two vertices are part of the same
 component.
 This prevents algorithms like Dijkstra's algorithm from having to iterate
 through an entire connected component if there exists no path between the
 start and finish vertex.
 The result of this is used to prove there exists no path between two vertices
 (in this code 
\begin_inset Quotes eld
\end_inset

Palmero
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Prague
\begin_inset Quotes erd
\end_inset

).
 Below are the functions involved.
\end_layout

\begin_layout Paragraph
lyx is shit
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defn breadth-first-search-connected-components! [graph start index]   (node-ins
ert! rb-queue start index nil)   (loop []     (when (not (red-black-tree-empty?
 rb-queue))     (let [current (pick-least-node (:root rb-queue))]      
 (remove-least-node! (:root rb-queue))       (dosync         (ref-set (:componen
t (get-vertex graph (:label current)))                   @(:value current)))
       (loop [neighbors             @(:neighbors (get-vertex graph (:label
 current)))]         (let [current-neighbor (first neighbors)]         
  (when (vertex-unseen? graph current-neighbor)             (node-insert!
 rb-queue current-neighbor index nil)))         (recur (rest neighbors))))
       (dosync         (ref-set (:status (get-vertex graph (:label current)))
 visited))     (recur))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The 
\begin_inset Quotes eld
\end_inset

breadth-first-search-connected-components!
\begin_inset Quotes erd
\end_inset

 function accepts 3 arguments graph, start and index.
 The function iterates through the entire connected component of the start
 vertex.
 First the algorithm adds the start vertex to the open-queue.
 While the queue is not empty it sets the left-most node of the red-black
 tree open-queue as the current vertex.
 Then the function sets the component value of the vertex equal to the index
 value passed to the function.
 Finally it adds all the unseen neighbors of the current vertex to the open-queu
e, sets the status of the current vertex to visited and recurs to the stage
 of checking whether the open-queue is empty.
 This function is called by the main indexing function below.
\end_layout

\begin_layout Paragraph
lyx is shit
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defn index-components! [graph]
\end_layout

\begin_layout Plain Layout

  (graph-reset! graph)
\end_layout

\begin_layout Plain Layout

  (loop [index 0]
\end_layout

\begin_layout Plain Layout

    (breadth-first-search-connected-components! graph
\end_layout

\begin_layout Plain Layout

                                                (remaining-unseen graph)
\end_layout

\begin_layout Plain Layout

                                                index)
\end_layout

\begin_layout Plain Layout

    (recur (inc index))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The 
\begin_inset Quotes eld
\end_inset

index-components!
\begin_inset Quotes erd
\end_inset

 function is a simple tail recursive loop that keeps track of the index
 value that is going to be passed to the breadth first search.
 First the status and distance values of the graph are reset.
 Then the loop calls the 
\begin_inset Quotes eld
\end_inset

breadth-first-search-connected-components!
\begin_inset Quotes erd
\end_inset

 using the first 
\begin_inset Quotes eld
\end_inset

unseen
\begin_inset Quotes erd
\end_inset

 vertex it finds as the start vertex.
 The loop recurs with the increment of the index and runs again.
 The loop fails when it can no longer find an 
\begin_inset Quotes eld
\end_inset

unseen
\begin_inset Quotes erd
\end_inset

 vertex in the graph.
\end_layout

\begin_layout Paragraph*
The time complexity of this function is tightly bound and linear O(n)= Ω(n)=Θ(n)
 as the breadth first search will iterate through the entire graph before
 the loop ends.
 The memory complexity of this function is tightly bound and constant O(1)=
 Ω(1)=Θ(1) as it only keeps track of a set amount of nodes at a time.
 This is theoretically the only way to label the connected components of
 a graph as regardless of the traversing function the entire set of vertices
 must be iterated through.
 Thanks to this being run after all the data has been added to the graph,
 the time complexity of proving there exists no path between two vertices
 is near constant due to Clojure's hash maps.
\end_layout

\begin_layout Section
Dijkstra's Algorithm Without Edge Weights
\end_layout

\begin_layout Paragraph*
This section describes the implementation of Dijkstra's algorithm, Dijkstra's
 algorithm finds the shortest path between two vertices in a graph.
 In this section only the implementation that does not take into account
 edge weights is discussed.
\end_layout

\begin_layout Subsection
Breadth First Search Function
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn breadth-first-search-dijkstra! [graph start finish]   (node-insert!
 rb-queue finish 0 nil)   (loop []     (when (not (red-black-tree-empty?
 rb-queue))     (let [current (pick-least-node (:root rb-queue))]      
 (remove-least-node! (:root rb-queue))       (dosync         (ref-set (:distance
 (get-vertex graph (:label current)))                   @(:value current)))
       (when (not (= (:label current) start))         (loop [neighbors 
              @(:neighbors (get-vertex graph (:label current)))]       
    (let [current-neighbor (first neighbors)]             (when (vertex-unseen?
 graph current-neighbor)               (node-insert! rb-queue current-neighbor
 (inc @(:value current)) nil)))           (recur (rest neighbors)))))  
     (dosync         (ref-set (:status (get-vertex graph (:label current)))
 visited))     (recur))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The algorithm above accepts three arguments one pointing to a graph within
 which are two nodes (start, finish) that are the remaining arguments.
 The algorithm finds the shortest path between these two nodes by running
 a breadth first search from the finish node searching for the start node.
 Breadth first search keeps track of an, 
\begin_inset Quotes eld
\end_inset

open queue
\begin_inset Quotes erd
\end_inset

 which is a set of vertices that are going to be processed, a set of visited
 or already processed vertices and a current vertex.
 
\end_layout

\begin_layout Paragraph*
The breadth first search is given the finish node which it adds to the open
 queue along with a value of zero.
 While the open queue is still populated the algorithm removes next vertex
 from open queue and sets it as current vertex.
 The current vertex's distance value (in the graph's record structure) is
 set to the value attributed to it in the open queue.
 In this case the distance is the amount of hops (edges) the node is away
 from the finish.
 Finally all adjacent vertices of the current vertex that have an 
\begin_inset Quotes eld
\end_inset

unseen
\begin_inset Quotes erd
\end_inset

 status (in the graph's record structure) are added to the open queue with
 the increment of the value of the current vertex.
 The current vertex's status is then set visited.
 
\end_layout

\begin_layout Paragraph*
The algorithm then choses its next vertex from the open queue and repeats
 the aforementioned steps until it reaches the start node.
 The breadth first search will iterate through the entire connected component
 if it does not reach the start node.
 It is at this point that the 
\begin_inset Quotes eld
\end_inset

dijkstra!
\begin_inset Quotes erd
\end_inset

 function would normally evaluate whether or not a path exists between the
 two nodes.
 However, in this implementation each vertex has already been marked with
 an index number corresponding to its connected component.
\end_layout

\begin_layout Paragraph*
The 
\begin_inset Quotes eld
\end_inset

dijkstra!
\begin_inset Quotes erd
\end_inset

 function first checks if the two nodes have equal values in the 
\begin_inset Quotes eld
\end_inset

component
\begin_inset Quotes erd
\end_inset

 section of their records.
 If the indices do not match there exists no path between the two nodes
 and the breadth first search will not be run.
 If this feature was not implemented the breadth first search algorithm
 would have the iterate through the entire connected component before it
 could assume that there exists no path between the two given nodes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

breadth-first-search!
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Documents/bfs-flow-chart.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Trace Back Function for Dijkstra's Algorithm
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn dijkstra-trace-back [graph start finish]
\end_layout

\begin_layout Plain Layout

  (loop [current start]
\end_layout

\begin_layout Plain Layout

    (println current)
\end_layout

\begin_layout Plain Layout

    (when (not (= current finish))
\end_layout

\begin_layout Plain Layout

      (recur (dijkstra-trace-back-pick-best current)))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

dijkstra-trace-back
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Desktop/Screen Shot 2020-06-03 at 7.30.11 PM.png

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The above algorithm is used after the marking phase of Dijkstra's algorithm
 without edge weights.
 The tracing back begins by setting the start vertex to be the current vertex.
 Next the algorithm prints the label of the current vertex.
 If the label of the current vertex is not equal to the finish argument
 the algorithm chooses the neighbor of the current vertex with the lowest
 distance value in its record and sets it to the new current vertex.
 After this the algorithm recurs back to the step where it prints the label
 and repeats stated steps until it reaches the finish.
 At this point Dijkstra's algorithm has finished and the shortest path between
 the start and finish vertices has been printed.
\end_layout

\begin_layout Subsubsection
Picking the Neighbor With The Lowest Distance To Finish
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn dijkstra-trace-back-pick-best [graph vertex]
\end_layout

\begin_layout Plain Layout

  (loop [neighbors @(:neighbors @(get-vertex graph vertex))
\end_layout

\begin_layout Plain Layout

         best-distance ##Inf
\end_layout

\begin_layout Plain Layout

         best-label nil]
\end_layout

\begin_layout Plain Layout

    (if (= (count neighbors) 1)
\end_layout

\begin_layout Plain Layout

      (if (< @(:distance @(get-vertex graph (first neighbors))) best-distance)
\end_layout

\begin_layout Plain Layout

        (first neighbors)
\end_layout

\begin_layout Plain Layout

        best-label)
\end_layout

\begin_layout Plain Layout

      (if (< @(:distance @(get-vertex graph (first neighbors))) best-distance)
\end_layout

\begin_layout Plain Layout

        (recur (rest neighbors)
\end_layout

\begin_layout Plain Layout

               @(:distance @(get-vertex graph (first neighbors)))
\end_layout

\begin_layout Plain Layout

               (first neighbors))
\end_layout

\begin_layout Plain Layout

        (recur (rest neighbors)
\end_layout

\begin_layout Plain Layout

                best-distance
\end_layout

\begin_layout Plain Layout

                best-label)))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Choosing the neighbor with the lowest distance to finish (without edge weights)
 is as simple as iterating through all the neighbors and keeping track of
 the lowest distance value over iterations.
 The above function accomplishes exactly that and returns the label of the
 neighbor with the lowest distance to finish.
 The time complexity of this function is tightly bound and linear O(n)=
 Ω(n)=Θ(n) where 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 is the number of neighbors of the vertex.
 This is because the distance each neighbor must be checked once to find
 the neighbor with the lowest value.
 The memory complexity of this function is not tightly bound O(n) Ω(1) as
 all of the neighbors must be stored in the loop at the beginning and one
 less is kept track off on each iteration.
\end_layout

\begin_layout Subsection
Dijkstra Function
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn dijkstra! [graph start finish]
\end_layout

\begin_layout Plain Layout

  (graph-reset! graph)
\end_layout

\begin_layout Plain Layout

  (if (= @(:component @(get-vertex graph start))
\end_layout

\begin_layout Plain Layout

         @(:component @(get-vertex graph finish)))
\end_layout

\begin_layout Plain Layout

    (do
\end_layout

\begin_layout Plain Layout

      (breadth-first-search-dijkstra graph start finish)
\end_layout

\begin_layout Plain Layout

      (dijkstra-trace-back graph start finish))
\end_layout

\begin_layout Plain Layout

    (println "No path exists!")))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

dijkstra!
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Desktop/Screen Shot 2020-06-03 at 7.17.54 PM.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The above function serves only to call all the helper functions associated
 with finding the shortest path between two vertices following Dijkstra's
 algorithm.
 First the function runs the graph reset.
 This is a simple recursive function that iterates through all the vertices
 of the graph and sets their status to unseen and distance to finish to
 infinity.
 The time complexity of this operation is tightly bound and linear O(n)=
 Ω(n)=Θ(n) as it must iterate through each and every node of the red-black
 tree of vertices.
\end_layout

\begin_layout Paragraph*
Next the function checks if the start and finish vertices are part of the
 same connected component.
 If they are, the function continues otherwise the function terminates without
 entering the marking phase as there exists no path between two nodes that
 are not part of the same connected component.
 The time complexity of this operation is nearly constant because all that
 is happening is the lookup of two nodes within the graph's hash map structure
 which contains the set of vertices.
\end_layout

\begin_layout Paragraph*
If the condition is satisfied the function will call the marking stage which
 is a modified breadth first search.
 Once the marking stage completes the function runs the trace back algorithm
 and terminates.
 
\end_layout

\begin_layout Subsection
Efficiency and Justification
\end_layout

\begin_layout Paragraph*
Aside from possible micro-optimizations this is the most efficient way to
 find the shortest path between two point on a graph.
 This algorithm has been chosen simply because there is no other algorithm
 to find the shortest path between two points in an unweighted graph.
\end_layout

\begin_layout Paragraph*
Several optimizations have already been added to this implementation.
 The worst case scenario for naive Dijkstra's algorithm occurs when there
 exists no path between the vertices supplied.
 With this implementation if the API gets more than 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 (where 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 is the amount of connected components) requests for nonexistent paths it
 will be more efficient.
 This is because the connected components are counted and marked after the
 entire graph has been recorded.
 The open-queue has also been optimized using a red black tree.
 The time complexity of this function is not tightly bound O(n
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

) and Ω(1) in a sparse graph.
\end_layout

\begin_layout Section
Finding the Shortest Path With Edge Weights
\end_layout

\begin_layout Paragraph*
This section discusses algorithms for finding the shortest path between
 two vertices in a weighted graph.
 
\end_layout

\begin_layout Subsection
Breadth First Search for A* Function
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn breadth-first-search-a*! [graph start finish]
\end_layout

\begin_layout Plain Layout

  (node-insert! rb-queue finish (great-circle-distance graph finish start)
 0)
\end_layout

\begin_layout Plain Layout

  (loop []
\end_layout

\begin_layout Plain Layout

    (when (not (red-black-tree-empty? rb-queue))
\end_layout

\begin_layout Plain Layout

    (let [current (pick-least-node (:root rb-queue) start)]
\end_layout

\begin_layout Plain Layout

      (remove-least-node! (:root rb-queue))
\end_layout

\begin_layout Plain Layout

      (dosync
\end_layout

\begin_layout Plain Layout

        (ref-set (:distance (get-vertex graph (:label current)))
\end_layout

\begin_layout Plain Layout

                 @(:value2 current)))
\end_layout

\begin_layout Plain Layout

      (when (not (= (:label current) start))
\end_layout

\begin_layout Plain Layout

        (loop [neighbors
\end_layout

\begin_layout Plain Layout

              @(:neighbors (get-vertex graph (:label current)))]
\end_layout

\begin_layout Plain Layout

          (let [current-neighbor (first neighbors)
\end_layout

\begin_layout Plain Layout

                edge-distance (:distance (get-edge graph
\end_layout

\begin_layout Plain Layout

                                                   current-neighbor
\end_layout

\begin_layout Plain Layout

                                                   (:label current)))
\end_layout

\begin_layout Plain Layout

                great-circle (great-circle-distance graph
\end_layout

\begin_layout Plain Layout

                                                    current-neighbor
\end_layout

\begin_layout Plain Layout

                                                    start)]
\end_layout

\begin_layout Plain Layout

            (when (vertex-unseen? graph current-neighbor)
\end_layout

\begin_layout Plain Layout

              (node-insert! rb-queue current-neighbor
\end_layout

\begin_layout Plain Layout

                            great-circle
\end_layout

\begin_layout Plain Layout

                            (+ @(:value current) edge-distance))))
\end_layout

\begin_layout Plain Layout

          (recur (rest neighbors)))))
\end_layout

\begin_layout Plain Layout

    (recur))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

breadth-first-search-a*!
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Documents/weighted-flow-chart.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The 
\begin_inset Quotes eld
\end_inset

breadth-first-search-a*!
\begin_inset Quotes erd
\end_inset

 function follows the same steps as any other breadth first search except
 it uses the great-circle distance of the vertex to the start to pick the
 next vertex to the open-queue.
 This is accomplished by storing the great-circle distance in the 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 section of the red-black tree nodes record, the edge weight distance is
 stored in 
\begin_inset Quotes eld
\end_inset

value2
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Weighted Trace Back Function for A*
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn weighted-trace-back [graph start finish]
\end_layout

\begin_layout Plain Layout

  (loop [current start]
\end_layout

\begin_layout Plain Layout

    (println current)
\end_layout

\begin_layout Plain Layout

    (when (not (= current finish))
\end_layout

\begin_layout Plain Layout

      (recur (weighted-trace-back-pick-best current)))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

wighted-trace-back
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Desktop/Screen Shot 2020-06-07 at 10.02.17 AM.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
After the marking stage of A* algorithm has finished the 
\begin_inset Quotes eld
\end_inset

weighted-trace-back
\begin_inset Quotes erd
\end_inset

 function is run.
 This function is capable of tracing the shortest path marked by both A*
 are Dijkstra with weights.
 Like its unweighted counterpart it accepts three arguments graph, start
 and finish.
 The function follows the exact same steps as its unweighted counterpart
 as well, the only difference is the function it uses to find the neighbor
 with the lowest value.
\end_layout

\begin_layout Subsubsection
Picking the Valid Neighbor With the Lowest Distance to Finish
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn weighted-trace-back-pick-best [graph vertex]
\end_layout

\begin_layout Plain Layout

  (loop [neighbors @(:neighbors @(get-vertex graph vertex))
\end_layout

\begin_layout Plain Layout

         best-distance ##Inf
\end_layout

\begin_layout Plain Layout

         best-label nil]
\end_layout

\begin_layout Plain Layout

    (if (= (count neighbors) 1)
\end_layout

\begin_layout Plain Layout

      (if (and
\end_layout

\begin_layout Plain Layout

            (< @(:distance @(get-vertex graph (first neighbors))) best-distance)
\end_layout

\begin_layout Plain Layout

            (= (- @(:distance @(get-vertex graph vertex))
\end_layout

\begin_layout Plain Layout

                  @(:distance @(get-vertex graph (first neighbors))))
\end_layout

\begin_layout Plain Layout

              (:weight @(get-edge graph (first neighbors) vertex))))
\end_layout

\begin_layout Plain Layout

        (first neighbors)
\end_layout

\begin_layout Plain Layout

        best-label)
\end_layout

\begin_layout Plain Layout

      (if (and
\end_layout

\begin_layout Plain Layout

            (< @(:distance @(get-vertex graph (first neighbors))) best-distance)
\end_layout

\begin_layout Plain Layout

            (= (- @(:distance @(get-vertex graph vertex))
\end_layout

\begin_layout Plain Layout

                  @(:distance @(get-vertex graph (first neighbors))))
\end_layout

\begin_layout Plain Layout

              (:weight @(get-edge graph (first neighbors) vertex))))
\end_layout

\begin_layout Plain Layout

        (recur (rest neighbors)
\end_layout

\begin_layout Plain Layout

               @(:distance @(get-vertex graph (first neighbors)))
\end_layout

\begin_layout Plain Layout

               (first neighbors))
\end_layout

\begin_layout Plain Layout

        (recur (rest neighbors)
\end_layout

\begin_layout Plain Layout

                best-distance
\end_layout

\begin_layout Plain Layout

                best-label)))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
In order to choose the neighbor with the lowest distance to finish this
 function must also validate that the distance of this vertex is correct.
 This is due to the nature of the marking stage of A*.
 The 
\begin_inset Quotes eld
\end_inset

weighted-trace-back-pick-best
\begin_inset Quotes erd
\end_inset

 function follows the same steps as the 
\begin_inset Quotes eld
\end_inset

dijkstra-trace-back-pick-best
\begin_inset Quotes erd
\end_inset

 function save for one detail.
 When deciding if a neighbor has a lower distance than the current distance
 the function checks if difference between the distance values of the neighbor
 and the vertex is equal to weight of the edge connecting them.
 If the previous condition is true and the distance is lower than the best
 distance the function either recurs with or returns the label of the neighbor
 being evaluated.
\end_layout

\begin_layout Subsection
A* Function
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn a*! [graph start finish]
\end_layout

\begin_layout Plain Layout

  (graph-reset! graph)
\end_layout

\begin_layout Plain Layout

  (def rb-queue (make-red-black-tree!))
\end_layout

\begin_layout Plain Layout

  (if (= @(:component @(get-vertex graph start))
\end_layout

\begin_layout Plain Layout

         @(:component @(get-vertex graph finish)))
\end_layout

\begin_layout Plain Layout

    (do
\end_layout

\begin_layout Plain Layout

      (breadth-first-search-a*! graph start finish)
\end_layout

\begin_layout Plain Layout

      (weighted-trace-back graph start finish))
\end_layout

\begin_layout Plain Layout

    (println "No path exists!")))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The 
\begin_inset Quotes eld
\end_inset

a*!
\begin_inset Quotes erd
\end_inset

 function follows the same exact steps as pictured in Figure 3.
 The only difference is the function calls the A* versions of breadth first
 search and trace back functions.
 A* is in principle a version of Dijkstra's algorithm that is capable of
 
\begin_inset Quotes eld
\end_inset

aiming
\begin_inset Quotes erd
\end_inset

 its search towards the start node.
 This generally makes it more efficient.
\end_layout

\begin_layout Subsection
Efficiency and Justification
\end_layout

\begin_layout Paragraph*
A* was chosen because it is one of the most efficient algorithms for finding
 a path in a weighted graph.
 In fact there are very few scenarios in which a different algorithm would
 outperform A*.
 In a trivially small graph Dijkstra's algorithm would outperform A* because
 they will both do the same amount of iterations.
 If multiple search operations are to be performed all coming from the same
 starting vertex a slightly modified Dijkstra's algorithm would work much
 better.
\end_layout

\begin_layout Paragraph*
A* uses heuristic values (latitude and longitude) in a type of 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

 first search (Pantůček 2020), since the data supplied contained latitude
 and longitude values for each vertex A* made the most efficient use of
 the data supplied.
 The time complexity of A* has a direct relationship with the heuristic
 function, it is not tightly bound and generally is not written as a function
 of the number of vertices in a graph.
 Speculations can be made that it is exponential for the length of the path
 returned in the upper bound (Santoso, 2010).
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Paragraph*
In general the subject of graph-related algorithms is an extremely nuanced
 part of mathematics in computing.
 There are countless real world applications, even for the algorithms discussed
 in this document (networking, GPS Navigation, logistics).
 The authors goal when writing this code was to write the most efficient
 versions of these algorithms within his capabilities.
 However, this is in no way a claim that there aren't any improvements to
 be made.
 With higher level functions such as this there are so many variables to
 change and optimize (data structure, helper functions) and due to this
 there is always some angle that has not been considered.
 It is the driving force behind competition and improvement in software
 over the years.
 What this assignment did accomplish was the delivery of a clear competent
 explanation of the given algorithms and a justification for the improvements
 that have been made.
\end_layout

\begin_layout Section
References
\end_layout

\begin_layout Paragraph*
Pantůček, D., 2020, Algorithms and Data Structures (ALDS-400-2001), Spring
 2020 21.
 A* Search Algorithm Finding Shortest Path in Weighted Graph, Presentation,
 Prague College, Prague.
\end_layout

\begin_layout Paragraph*
Pantůček, D., 2020, Algorithms and Data Structures (ALDS-400-2001), Spring
 2020 17.
 Dijkstra’s Algorithm Finding Shortest Path, Presentation, Prague College,
 Prague.
\end_layout

\begin_layout Paragraph*
Santoso, L.
 W., 2010, Performance Analysis of Dijkstra, A* and Ant Algorithm for Finding
 Optimal Path Case Study: Surabaya City Map, Article, Petra Christian University
, Surabaya.
\end_layout

\end_body
\end_document
