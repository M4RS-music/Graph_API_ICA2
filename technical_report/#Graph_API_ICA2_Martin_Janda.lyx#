#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "courier" "default"
\font_math "newtxmath" "auto"
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype true
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Algorithms For Graph Structures
\end_layout

\begin_layout Author
Martin Janda
\end_layout

\begin_layout Paragraph*
Prague College
\end_layout

\begin_layout Paragraph*
Algorithms and Data Structures (FT)
\end_layout

\begin_layout Paragraph*
Dominik Pantůček
\end_layout

\begin_layout Paragraph*
Shortest Route(s)
\end_layout

\begin_layout Paragraph*
ICA2
\end_layout

\begin_layout Paragraph*
1112 Words
\end_layout

\begin_layout Paragraph*
Semester 2001
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Scenario
\end_layout

\begin_layout Paragraph*
The assignment provides a set of vertices (cities or road crossings in the
 E.U.) and a set of edges (major E.U.
 roads) as commands meant to be passed to an application program interface
 designed by the student.
 The student was given two cities and asked to code an algorithm in Clojure
 that was capable of finding the shortest path (or proving one does not
 exist) between each city and Prague.
 The student was given 
\begin_inset Quotes eld
\end_inset

Nuremberg
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Palmero
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Aim
\end_layout

\begin_layout Paragraph*
The aim of the assignment was to describe the implementation of the algorithms
 specified by the assignment brief.
 This technical report also adresses the graph and helper structures that
 have been implemented as they are a large part of the code being submitted.
 All code in this doccument was written by the author in Clojure a list
 proccessing programming language.
\end_layout

\begin_layout Section
Prerequisite Structures and Functions
\end_layout

\begin_layout Paragraph*
The following are descriptions of major structures and functions that were
 implemented in order to create an efficient interface between implemented
 algorithms and the data supplied by the assignment.
\end_layout

\begin_layout Subsection
Data Structures
\end_layout

\begin_layout Paragraph*
This subsection addresses the underlying record structure of the implementation.
 Words on the efficiency of and justifications for these structures will
 be in subsection X.X.
\end_layout

\begin_layout Subsubsection
Red-Black Trees
\end_layout

\begin_layout Paragraph*
The main data structure used in this implementation is a red-black tree.
 A red-black tree is a self balancing form of a binary search tree.
 Red-black trees are responsible for storing the vertices, edges and open-queue
 (for breadth first search) in this implementation.
 The red-black tree is is defined by the following code, a reference to
 the root node of the tree.
 The record on line one is for the open queue and the record on line two
 is used for the vertices and edges.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defrecord Red-Black-Tree [root])
\end_layout

\begin_layout Plain Layout

(defrecord Red-Black-Tree-Map [root])
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The root of the tree is a reference to a node.
 Tree nodes are defined by the code below.
 The two lines correspond to the open-queue, vertices and edges as with
 the red-black tree definitions.
 Both types of node keep track of the following
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

color
\begin_inset Quotes erd
\end_inset

: reference to the color of the node, either red or black, used to keep
 the tree balanced by related functions.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

: reference to the node that is to the left of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

: reference to the node that is to the right of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

parent
\begin_inset Quotes erd
\end_inset

: reference to the parent of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

child
\begin_inset Quotes erd
\end_inset

: reference to the value of which child the node is of its parent (left,
 right, root).
\end_layout

\begin_layout Paragraph*
The open-queue node stores the label and value of each node and uses the
 value to sort the nodes during insertion.
 The vertex or edge tree node stores 
\begin_inset Quotes eld
\end_inset

hashl
\begin_inset Quotes erd
\end_inset

, a hashed label of the vertex or edge, and 
\begin_inset Quotes eld
\end_inset

grecord
\begin_inset Quotes erd
\end_inset

, the record structure of the vertex or node (see 3.1.2 Graph).
 The vertex and edge trees are sorted based on the hashed labels.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defrecord Red-Black-Node [label value color left right parent child])
\end_layout

\begin_layout Plain Layout

(defrecord Red-Black-Map-Node [hashl grecord color left right parent child])
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Graph
\end_layout

\begin_layout Paragraph*
Graphs can be represented in many ways and in this implementation the author
 has chosen to use red-black trees with hash lookup to store a set of vertices
 and a set of edges.
 Each set has its own tree and these two trees make up the entire 
\begin_inset Quotes eld
\end_inset

Graph.
\begin_inset Quotes erd
\end_inset

 record.
 The following code defines the graph's record structure.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defrecord Graph [vertices edges])
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Within the 
\begin_inset Quotes eld
\end_inset

grecord
\begin_inset Quotes erd
\end_inset

 references of the nodes within the red-black trees in either 
\begin_inset Quotes eld
\end_inset

vertices
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

edges
\begin_inset Quotes erd
\end_inset

 are 
\begin_inset Quotes eld
\end_inset

Vertex.
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Edge.
\begin_inset Quotes erd
\end_inset

 record structures respectively.
 These records contain all data relevant to either the vertex or edge.
\end_layout

\begin_layout Paragraph*
The folowing code defines the vertex and edge record structure.
 The supplied pieces of data for the vertex are 
\begin_inset Quotes eld
\end_inset

label
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

neigbors
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

latitude
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

longitude
\begin_inset Quotes erd
\end_inset

 though the neighbors are implied from the edges.
 The 
\begin_inset Quotes eld
\end_inset

status
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

distance
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

component
\begin_inset Quotes erd
\end_inset

 of the vertex are utility data used by functions performing algorithms
 on the data.
 The 
\begin_inset Quotes eld
\end_inset

status
\begin_inset Quotes erd
\end_inset

 allows the breadth first search to check whether a vertex has yet been
 visited.
 The 
\begin_inset Quotes eld
\end_inset

distance
\begin_inset Quotes erd
\end_inset

 is where the distance from finish of the vertex is stored.
 Finanly 
\begin_inset Quotes eld
\end_inset

component
\begin_inset Quotes erd
\end_inset

 stores the indicie of the connected component to which the vertex belongs.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defrecord Vertex [label neighbors latitude longitude status distance component]
)
\end_layout

\begin_layout Plain Layout

(defrecord Edge [from to weight label])
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The edge record structure contains only data supplied by the assignment.
 
\end_layout

\begin_layout Subsection
Adding Data
\end_layout

\begin_layout Paragraph*
The assignment supplied a list of statements that were meant to use the
 following functions:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defn graph-add-vertex! [graph label latitude longitude]
\end_layout

\begin_layout Plain Layout

  (let [hashed-label (hash-label label)]
\end_layout

\begin_layout Plain Layout

    (when (not (red-black-hashmap-contains? hashed-label (:root @(:vertices
 graph))))
\end_layout

\begin_layout Plain Layout

      (map-node-insert-helper-2!
\end_layout

\begin_layout Plain Layout

        (:root @(:vertices graph))
\end_layout

\begin_layout Plain Layout

        nil         hashed-label
\end_layout

\begin_layout Plain Layout

        (Vertex.
 label (ref '()) latitude longitude (ref unseen) (ref ##Inf) (ref nil))
\end_layout

\begin_layout Plain Layout

        false))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defn graph-add-edge! [graph from to label weight]
\end_layout

\begin_layout Plain Layout

  (let [hashed-edge-key (hash-label (edge-key from to))]
\end_layout

\begin_layout Plain Layout

    (when (not (red-black-hashmap-contains? hashed-edge-key (:root @(:edges
 graph)))))
\end_layout

\begin_layout Plain Layout

      (map-node-insert-helper-2!
\end_layout

\begin_layout Plain Layout

        (:root @(:edges graph))
\end_layout

\begin_layout Plain Layout

        nil
\end_layout

\begin_layout Plain Layout

        hashed-edge-key
\end_layout

\begin_layout Plain Layout

        (Edge.
 from to weight label)
\end_layout

\begin_layout Plain Layout

        true)))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
These two functions 
\end_layout

\begin_layout Section
Dijkstra's Algorithm Without Edge Weights
\end_layout

\begin_layout Paragraph*
This section describes the implementation of Dijkstra's algorithm, Dijkstra's
 algorithm finds the shortest path between two vertices in a graph.
 In this section only the implementation that does not take into account
 edge weights is discussed.
\end_layout

\begin_layout Subsection
Breadth First Search Algorithm
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defn breadth-first-search-dijkstra [graph start finish]
\end_layout

\begin_layout Plain Layout

  (node-insert! rb-queue finish 0)
\end_layout

\begin_layout Plain Layout

  (loop []
\end_layout

\begin_layout Plain Layout

    (when (not (red-black-tree-empty? rb-queue))
\end_layout

\begin_layout Plain Layout

    (let [current (pick-least-node (:root rb-queue))]
\end_layout

\begin_layout Plain Layout

      (remove-least-node! (:root rb-queue))
\end_layout

\begin_layout Plain Layout

      (dosync
\end_layout

\begin_layout Plain Layout

        (ref-set (:distance @(get-vertex graph (:label current)))
\end_layout

\begin_layout Plain Layout

                  @(:value current)))
\end_layout

\begin_layout Plain Layout

      (when (not (= (:label current) start))
\end_layout

\begin_layout Plain Layout

        (loop [neighbors
\end_layout

\begin_layout Plain Layout

              @(:neighbors @(get-vertex graph (:label current)))]
\end_layout

\begin_layout Plain Layout

          (let [current-neighbor (first neighbors)]
\end_layout

\begin_layout Plain Layout

            (when (get-vertex-unseen? graph current-neighbor)
\end_layout

\begin_layout Plain Layout

              (node-insert! rb-queue current-neighbor (inc @(:value @current))))
)
\end_layout

\begin_layout Plain Layout

          (recur (rest neighbors)))))
\end_layout

\begin_layout Plain Layout

    (recur))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The algorithm above accepts three arguments one pointing to a graph within
 which are two nodes (start, finish) that are the remaining arguments.
 The algorithm finds the shortest path between these two nodes by running
 a breadth first search from the finish node searching for the start node.
 Breadth first search keeps track of an, 
\begin_inset Quotes eld
\end_inset

open queue
\begin_inset Quotes erd
\end_inset

 which is a set of vertices that are going to be processed, a set of visited
 or already proccessed vertices and a current vertex.
 The breadth first search is given the finish node which it adds to the
 open queue.
 If the open queue is still populated the algorithm removes next vertex
 from open queue and sets it as current vertex.
 The current vertex's distance value (in its record structure) is set to
 its distance from the finish node.
 In this case the distance is the amount of hops (edges) the node is away
 from the finish.
 Finally all adjacent verticies of the current vertex that have an 
\begin_inset Quotes eld
\end_inset

unseen status
\begin_inset Quotes erd
\end_inset

 (in ther record structure) are added to the open queue and the current
 vertex's status is set visited.
 The algorithm then choses its next vertex from the open queue and repeats
 the afformentioned steps untill it reaches the start node.
 It is at this point that the algorithm would normally evaluate whether
 or not a path exists between the two nodes however in this implementation
 each vertex has already been marked with an index number corresponding
 to its connected component.
 The algorithm first checks if the two nodes have equal values in the 
\begin_inset Quotes eld
\end_inset

component
\begin_inset Quotes erd
\end_inset

 sections of their records.
 If the indicies do not match there exists no path between the two nodes
 and the breadth first search will not run.
 If this feature was not implemented the algorithm would have the itterate
 through the entire connected component before it could assume that there
 exists no path between the two given nodes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

breadth-first-search!
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Documents/bfs_flowchart.png
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Trace Back Function for Dijkstra's Algorithm
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defn dijkstra-trace-back [graph start finish]
\end_layout

\begin_layout Plain Layout

  (loop [current start]
\end_layout

\begin_layout Plain Layout

    (println current)
\end_layout

\begin_layout Plain Layout

    (when (not (= current finish))
\end_layout

\begin_layout Plain Layout

      (recur (dijkstra-trace-back-pick-best current)))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

dijksta-trace-back
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Desktop/Screen Shot 2020-06-03 at 7.30.11 PM.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The above algorithm is used after the marking phase of any Dijkstra's algorithm
 (with or without weights).
 The tracing back begins by setting the start vertex to be the current vertex.
 Next the algorithm prints the label of the current vertex.
 If the label of the current vertex is not equal to the finish argument
 the algorithm chooses the neighbor of the current vertex with the lowest
 distance value in its record and sets it to the new current vertex.
 After this the algorithm recurs back to the step where it prints the label
 and repeats stated steps until it reaches the finish.
 At this point Dijkstra's algorithm has finished and the shortest path between
 the start and finish vertices has been printed.
\end_layout

\begin_layout Subsubsection
Picking the Neighbor With The Lowest Distance To Finish
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defn dijkstra-trace-back-pick-best [vertex]
\end_layout

\begin_layout Plain Layout

  (loop [neighbors @(:neighbors @(get-vertex graph (:label current)))
\end_layout

\begin_layout Plain Layout

         best-distance ##Inf
\end_layout

\begin_layout Plain Layout

         best-label nil]
\end_layout

\begin_layout Plain Layout

    (if (= (count neighbors) 1)
\end_layout

\begin_layout Plain Layout

      (if (< @(:distance @(get-vertex graph (first neighbors))) best-distance)
\end_layout

\begin_layout Plain Layout

        (first neighbors)
\end_layout

\begin_layout Plain Layout

        best-label)
\end_layout

\begin_layout Plain Layout

      (if (< @(:distance @(get-vertex graph (first neighbors))) best-distance)
\end_layout

\begin_layout Plain Layout

        (recur (rest neighbors)
\end_layout

\begin_layout Plain Layout

               @(:distance @(get-vertex graph (first neighbors)))
\end_layout

\begin_layout Plain Layout

               (first neighbors))
\end_layout

\begin_layout Plain Layout

        (recur (rest neighbors)
\end_layout

\begin_layout Plain Layout

                best-distance
\end_layout

\begin_layout Plain Layout

                best-label)))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Chosing the neighbor with the lowest distance to finish is as simple as
 iterating through all the neighbors and keeping track of the lowest distance
 value over iterations.
 The above function acomplishes exactly that and returns the label of the
 neighbor with the lowest distance to finish.
 The time complexity of this function is tightly bound and linear O(n)=
 Ω(n)=Θ(n) where 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 is the number of neighbors of the vertex.
 This is because the distance each neighbor must be checked once to find
 the neighbor with the lowest value.
 The memory complexity of this function is tightly bound and linear O(n)=
 Ω(n)=Θ(n) as all of the nei
\end_layout

\begin_layout Subsection
Dijkstra Function
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defn dijkstra! [graph start finish]
\end_layout

\begin_layout Plain Layout

  (graph-reset! graph)
\end_layout

\begin_layout Plain Layout

  (if (= @(:component @(get-vertex graph start))
\end_layout

\begin_layout Plain Layout

         @(:component @(get-vertex graph finish)))
\end_layout

\begin_layout Plain Layout

    (do
\end_layout

\begin_layout Plain Layout

      (breadth-first-search-dijkstra graph start finish)
\end_layout

\begin_layout Plain Layout

      (dijkstra-trace-back graph start finish))
\end_layout

\begin_layout Plain Layout

    (println "No path exists!")))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

dijkstra!
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Desktop/Screen Shot 2020-06-03 at 7.17.54 PM.png
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The above function serves only to call all the helper functions associated
 with finding the shortest path between two vertices following Dijkstra's
 algorithm.
 First the function runs the graph reset.
 This is a simple recursive function that iterates through all the vertices
 of the graph and sets their status to unseen and distance to finish to
 infinity.
 The time complexity of this operation is tightly bound and linear O(n)=
 Ω(n)=Θ(n) as it must iterate through each and every node of the red-black
 tree of vertices.
 The memory complexity of this varys throughout each iteration of the algorithm
 and is roughly equal to the width of the tree at the depth of the corresponding
 iteration this means it is tightly bound O(2
\begin_inset script superscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

)= Ω(2
\begin_inset script superscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

)=Θ(2
\begin_inset script superscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

), where 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

 is the index of the iteration starting at 0.
 This is however a rough estimate and may vary for leaf nodes as red-black
 trees stay within a 1 node difference in maximum and minimum depth.
\end_layout

\begin_layout Paragraph*
Next the function checks if the start and finish vertices are part of the
 same connected component.
 If they are, the function continues otherwise the function terminates without
 entering the marking phase as there exists no path between two nodes that
 are not part of the same connected component.
 The time complexity of this operation is O(log n) or Ω(1) and is not tightly
 bound because all that is happening is the lookup of two nodes within the
 graph's red-black tree structure which contains the set of vertices.
 The memory complexity is tightly bound and constant O(1)= Ω(1)=Θ(1) as
 only one node is being accessed at a time while searching for the specified
 node.
\end_layout

\begin_layout Paragraph*
If the condition is satisfied the function will call the marking stage which
 is a modified breadth first search.
 Once the marking stage completes the function runs the trace back algorithm
 and terminates.
 The functions/algorithms mentioned in this paragraph will be further stated
 and analyzed in the following subsections.
\end_layout

\end_body
\end_document
