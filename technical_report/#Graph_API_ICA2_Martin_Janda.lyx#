#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "courier" "default"
\font_math "newtxmath" "auto"
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype true
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 20page%
\topmargin 3pheight%
\rightmargin 20page%
\bottommargin 3pheight%
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Algorithms For Graph Structures
\end_layout

\begin_layout Author
Martin Janda
\end_layout

\begin_layout Paragraph*
Prague College
\end_layout

\begin_layout Paragraph*
Algorithms and Data Structures (FT)
\end_layout

\begin_layout Paragraph*
Dominik Pantůček
\end_layout

\begin_layout Paragraph*
Shortest Route(s)
\end_layout

\begin_layout Paragraph*
ICA2
\end_layout

\begin_layout Paragraph*
1971 Words
\end_layout

\begin_layout Paragraph*
Semester 2001
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Scenario
\end_layout

\begin_layout Paragraph*
The assignment provides a set of vertices (cities or road crossings in the
 E.U.) and a set of edges (major E.U.
 roads) as commands meant to be passed to an application program interface
 designed by the student.
 The student was given two cities and asked to code an algorithm in Clojure
 that was capable of finding the shortest path (or proving one does not
 exist) between each city and Prague.
 The student was given 
\begin_inset Quotes eld
\end_inset

Nuremberg
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Palmero
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Aim
\end_layout

\begin_layout Paragraph*
The aim of the assignment was to describe the implementation of the algorithms
 specified by the assignment brief.
 This technical report also adresses the graph and helper structures that
 have been implemented as they are a large part of the code being submitted
 and contribute directly to the efficiency of the algorithms.
 All code in this doccument was written by the author in Clojure a list
 proccessing programming language.
\end_layout

\begin_layout Section
Prerequisite Structures and Functions
\end_layout

\begin_layout Paragraph*
The following are descriptions of major structures and functions that were
 implemented in order to create an efficient interface between implemented
 algorithms and the data supplied by the assignment.
\end_layout

\begin_layout Subsection
Data Structures
\end_layout

\begin_layout Paragraph*
This subsection addresses the underlying record structures of the implementation.
 Words on the efficiency of and justifications for these structures are
 in subsection 3.2.
\end_layout

\begin_layout Subsubsection
Red-Black Trees
\end_layout

\begin_layout Paragraph*
The data structure used for the open-queue in this implementation is a red-black
 tree.
 A red-black tree is a self balancing form of a binary search tree.
 The red-black tree is is defined by the following code, a reference to
 the root node of the tree.
\end_layout

\begin_layout Paragraph*
lyx is shit
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(defrecord Red-Black-Tree [root])
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The root of the tree is a reference to a node.
 Tree nodes are defined by the code below and keep track of the following:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

label
\begin_inset Quotes erd
\end_inset

: the label of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

: the value by which the node is sorted.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

color
\begin_inset Quotes erd
\end_inset

: reference to the color of the node, either red or black, used to keep
 the tree balanced by related functions.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

: reference to the node that is to the left of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

: reference to the node that is to the right of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

parent
\begin_inset Quotes erd
\end_inset

: reference to the parent of the node.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

child
\begin_inset Quotes erd
\end_inset

: reference to the value of which child the node is of its parent (left,
 right, root).
\end_layout

\begin_layout Paragraph*
lyx is shit
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defrecord Red-Black-Node [label value color left right parent child])
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hash Maps
\end_layout

\begin_layout Paragraph*
Clojure's built in hash map data structure is used to store all the nodes
 and vertices of the graph.
 The graph itself is a record that contains references to two hash maps,
 one for the vertices and one for the edges.
\end_layout

\begin_layout Paragraph*
lyx is shit
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defrecord Graph [vertices edges])
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Adding Data
\end_layout

\begin_layout Paragraph*
When adding nodes to the open-queue the function 
\begin_inset Quotes eld
\end_inset

node-insert!
\begin_inset Quotes erd
\end_inset

 is called.
\end_layout

\begin_layout Paragraph*
lyx is shit
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn node-insert! [tree label value]
\end_layout

\begin_layout Plain Layout

  (if (red-black-tree-empty? tree)
\end_layout

\begin_layout Plain Layout

    (dosync
\end_layout

\begin_layout Plain Layout

      (ref-set (:root tree)
\end_layout

\begin_layout Plain Layout

       (make-node! label value Black nil Root)))
\end_layout

\begin_layout Plain Layout

    (cond
\end_layout

\begin_layout Plain Layout

     (< value @(:value @(:root tree)))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:left @(:root tree)) (:root tree) label value
 Left)
\end_layout

\begin_layout Plain Layout

      (> value @(:value @(:root tree)))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:right @(:root tree)) (:root tree) label value
 Right)
\end_layout

\begin_layout Plain Layout

      (= value @(:value @(:root tree)))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:right @(:root tree)) (:root tree) label value
 Right))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn node-insert-helper! [node parent label value child]
\end_layout

\begin_layout Plain Layout

  (if (tree-node-empty? node)
\end_layout

\begin_layout Plain Layout

    (do
\end_layout

\begin_layout Plain Layout

      (dosync
\end_layout

\begin_layout Plain Layout

        (ref-set node
\end_layout

\begin_layout Plain Layout

          (make-node! label value Red @parent child)))
\end_layout

\begin_layout Plain Layout

      (red-black-rules-checker! node))
\end_layout

\begin_layout Plain Layout

    (cond
\end_layout

\begin_layout Plain Layout

      (< value @(:value @node))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:left @node) node label value Left)
\end_layout

\begin_layout Plain Layout

      (> value @(:value @node))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:right @node) node label value Right)
\end_layout

\begin_layout Plain Layout

      (= value @(:value @node))
\end_layout

\begin_layout Plain Layout

        (node-insert-helper! (:right @node) node label value Right))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
These functions follow the standard procedure for inserting a node into
 a binary search tree.
 If the node being inserted is not the root of the red-black tree the 
\begin_inset Quotes eld
\end_inset

node-insert-helper!
\begin_inset Quotes erd
\end_inset

 function is called and it runs the 
\begin_inset Quotes eld
\end_inset

red-black-rules-checker!
\begin_inset Quotes erd
\end_inset

 function after the insertion.
 The 
\begin_inset Quotes eld
\end_inset

red-black-rules-checker!
\begin_inset Quotes erd
\end_inset

 function checks if the tree is still a red-black tree and performs all
 neccessary rotations and color changes necessary to balance and restore
 its state.
\end_layout

\begin_layout Subsection
Justification
\end_layout

\begin_layout Paragraph*
Using a red-black tree has a number of benefits.
 Using a list for the open-queue in breadth first search his not optimal.
 In clojure lists are single-linked which means that the head of the list
 contains a reference to only the first node and nodes only contain a reference
 to the next node and not the previous.
 This means that appending to the list would have a tightly bound linear
 time complexity O(n)= Ω(n)=Θ(n).
 Furthermore accessing the node with the lowest value would have a time
 complexity of O(n) and for the best case scenarion Ω(1), as the list is
 not sorted.
\end_layout

\begin_layout Paragraph*
The red-black tree solves this problem as it is a form of a binary search
 tree.
 The tree is sorted and thus accessing the node with the lowest value is
 as simple as going to the left-most node of the tree.
 The time complexity of this is tightly bound O(log n)= Ω(log n)=Θ(log n)
 and the memory complexity is constant.
 For insertions the time complexity is not tightly bound O(log n) and Ω(1)
 if the tree is empty.
 This logarithmic time complexity is due to the maximum height of any red-black
 tree which is O(log n) thanks to the self balancing nature of the tree.
 
\end_layout

\begin_layout Paragraph*
It was considered that the entire graph structure could be represented using
 red-black trees.
 However, the effieciency of this could not be justified as clojure has
 a hash map structure that has a near constant time complexity for accessing
 and inserting nodes.
\end_layout

\begin_layout Section
Dijkstra's Algorithm Without Edge Weights
\end_layout

\begin_layout Paragraph*
This section describes the implementation of Dijkstra's algorithm, Dijkstra's
 algorithm finds the shortest path between two vertices in a graph.
 In this section only the implementation that does not take into account
 edge weights is discussed.
\end_layout

\begin_layout Subsection
Breadth First Search Algorithm
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn breadth-first-search-dijkstra [graph start finish]
\end_layout

\begin_layout Plain Layout

  (node-insert! rb-queue finish 0)
\end_layout

\begin_layout Plain Layout

  (loop []
\end_layout

\begin_layout Plain Layout

    (when (not (red-black-tree-empty? rb-queue))
\end_layout

\begin_layout Plain Layout

    (let [current (pick-least-node (:root rb-queue))]
\end_layout

\begin_layout Plain Layout

      (remove-least-node! (:root rb-queue))
\end_layout

\begin_layout Plain Layout

      (dosync
\end_layout

\begin_layout Plain Layout

        (ref-set (:distance @(get-vertex graph (:label current)))
\end_layout

\begin_layout Plain Layout

                  @(:value current)))
\end_layout

\begin_layout Plain Layout

      (when (not (= (:label current) start))
\end_layout

\begin_layout Plain Layout

        (loop [neighbors
\end_layout

\begin_layout Plain Layout

              @(:neighbors @(get-vertex graph (:label current)))]
\end_layout

\begin_layout Plain Layout

          (let [current-neighbor (first neighbors)]
\end_layout

\begin_layout Plain Layout

            (when (get-vertex-unseen? graph current-neighbor)
\end_layout

\begin_layout Plain Layout

              (node-insert! rb-queue current-neighbor (inc @(:value current)))))
\end_layout

\begin_layout Plain Layout

          (recur (rest neighbors)))))
\end_layout

\begin_layout Plain Layout

    (recur))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The algorithm above accepts three arguments one pointing to a graph within
 which are two nodes (start, finish) that are the remaining arguments.
 The algorithm finds the shortest path between these two nodes by running
 a breadth first search from the finish node searching for the start node.
 Breadth first search keeps track of an, 
\begin_inset Quotes eld
\end_inset

open queue
\begin_inset Quotes erd
\end_inset

 which is a set of vertices that are going to be processed, a set of visited
 or already proccessed vertices and a current vertex.
 
\end_layout

\begin_layout Paragraph*
The breadth first search is given the finish node which it adds to the open
 queue along with a value of zero.
 While the open queue is still populated the algorithm removes next vertex
 from open queue and sets it as current vertex.
 The current vertex's distance value (in the graph's record structure) is
 set to the value attributed to it in the open queue.
 In this case the distance is the amount of hops (edges) the node is away
 from the finish.
 Finally all adjacent verticies of the current vertex that have an 
\begin_inset Quotes eld
\end_inset

unseen
\begin_inset Quotes erd
\end_inset

 status (in the graph's record structure) are added to the open queue with
 the increment of the value of the current vertex.
 The current vertex's status is then set visited.
 
\end_layout

\begin_layout Paragraph*
The algorithm then choses its next vertex from the open queue and repeats
 the afformentioned steps untill it reaches the start node.
 The breadth first search will iterate through the entire connected component
 if it does not reach the start node.
 It is at this point that the 
\begin_inset Quotes eld
\end_inset

dijkstra!
\begin_inset Quotes erd
\end_inset

 function would normally evaluate whether or not a path exists between the
 two nodes.
 However, in this implementation each vertex has already been marked with
 an index number corresponding to its connected component.
\end_layout

\begin_layout Paragraph*
The 
\begin_inset Quotes eld
\end_inset

dijkstra!
\begin_inset Quotes erd
\end_inset

 function first checks if the two nodes have equal values in the 
\begin_inset Quotes eld
\end_inset

component
\begin_inset Quotes erd
\end_inset

 section of their records.
 If the indicies do not match there exists no path between the two nodes
 and the breadth first search will not be run.
 If this feature was not implemented the breadth first search algorithm
 would have the itterate through the entire connected component before it
 could assume that there exists no path between the two given nodes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

breadth-first-search!
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Documents/bfs-flow-chart.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Trace Back Function for Dijkstra's Algorithm
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn dijkstra-trace-back [graph start finish]
\end_layout

\begin_layout Plain Layout

  (loop [current start]
\end_layout

\begin_layout Plain Layout

    (println current)
\end_layout

\begin_layout Plain Layout

    (when (not (= current finish))
\end_layout

\begin_layout Plain Layout

      (recur (dijkstra-trace-back-pick-best current)))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

dijksta-trace-back
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Desktop/Screen Shot 2020-06-03 at 7.30.11 PM.png

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The above algorithm is used after the marking phase of Dijkstra's algorithm
 without edge weights.
 The tracing back begins by setting the start vertex to be the current vertex.
 Next the algorithm prints the label of the current vertex.
 If the label of the current vertex is not equal to the finish argument
 the algorithm chooses the neighbor of the current vertex with the lowest
 distance value in its record and sets it to the new current vertex.
 After this the algorithm recurs back to the step where it prints the label
 and repeats stated steps until it reaches the finish.
 At this point Dijkstra's algorithm has finished and the shortest path between
 the start and finish vertices has been printed.
\end_layout

\begin_layout Subsubsection
Picking the Neighbor With The Lowest Distance To Finish
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn dijkstra-trace-back-pick-best [graph vertex]
\end_layout

\begin_layout Plain Layout

  (loop [neighbors @(:neighbors @(get-vertex graph vertex))
\end_layout

\begin_layout Plain Layout

         best-distance ##Inf
\end_layout

\begin_layout Plain Layout

         best-label nil]
\end_layout

\begin_layout Plain Layout

    (if (= (count neighbors) 1)
\end_layout

\begin_layout Plain Layout

      (if (< @(:distance @(get-vertex graph (first neighbors))) best-distance)
\end_layout

\begin_layout Plain Layout

        (first neighbors)
\end_layout

\begin_layout Plain Layout

        best-label)
\end_layout

\begin_layout Plain Layout

      (if (< @(:distance @(get-vertex graph (first neighbors))) best-distance)
\end_layout

\begin_layout Plain Layout

        (recur (rest neighbors)
\end_layout

\begin_layout Plain Layout

               @(:distance @(get-vertex graph (first neighbors)))
\end_layout

\begin_layout Plain Layout

               (first neighbors))
\end_layout

\begin_layout Plain Layout

        (recur (rest neighbors)
\end_layout

\begin_layout Plain Layout

                best-distance
\end_layout

\begin_layout Plain Layout

                best-label)))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Chosing the neighbor with the lowest distance to finish (without edge weights)
 is as simple as iterating through all the neighbors and keeping track of
 the lowest distance value over iterations.
 The above function acomplishes exactly that and returns the label of the
 neighbor with the lowest distance to finish.
 The time complexity of this function is tightly bound and linear O(n)=
 Ω(n)=Θ(n) where 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 is the number of neighbors of the vertex.
 This is because the distance each neighbor must be checked once to find
 the neighbor with the lowest value.
 The memory complexity of this function is not tightly bound O(n) Ω(1) as
 all of the neighbors must be stored in the loop at the beggining and one
 less is kept track off on each iteration.
\end_layout

\begin_layout Subsection
Dijkstra Function
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp,numbers=left,basicstyle={\ttfamily},tabsize=1"
inline false
status open

\begin_layout Plain Layout

(defn dijkstra! [graph start finish]
\end_layout

\begin_layout Plain Layout

  (graph-reset! graph)
\end_layout

\begin_layout Plain Layout

  (if (= @(:component @(get-vertex graph start))
\end_layout

\begin_layout Plain Layout

         @(:component @(get-vertex graph finish)))
\end_layout

\begin_layout Plain Layout

    (do
\end_layout

\begin_layout Plain Layout

      (breadth-first-search-dijkstra graph start finish)
\end_layout

\begin_layout Plain Layout

      (dijkstra-trace-back graph start finish))
\end_layout

\begin_layout Plain Layout

    (println "No path exists!")))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart for 
\begin_inset Quotes eld
\end_inset

dijkstra!
\begin_inset Quotes erd
\end_inset

 Function
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/martinjanda/Desktop/Screen Shot 2020-06-03 at 7.17.54 PM.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The above function serves only to call all the helper functions associated
 with finding the shortest path between two vertices following Dijkstra's
 algorithm.
 First the function runs the graph reset.
 This is a simple recursive function that iterates through all the vertices
 of the graph and sets their status to unseen and distance to finish to
 infinity.
 The time complexity of this operation is tightly bound and linear O(n)=
 Ω(n)=Θ(n) as it must iterate through each and every node of the red-black
 tree of vertices.
\end_layout

\begin_layout Paragraph*
Next the function checks if the start and finish vertices are part of the
 same connected component.
 If they are, the function continues otherwise the function terminates without
 entering the marking phase as there exists no path between two nodes that
 are not part of the same connected component.
 The time complexity of this operation is nearly constant because all that
 is happening is the lookup of two nodes within the graph's hash map structure
 which contains the set of vertices.
\end_layout

\begin_layout Paragraph*
If the condition is satisfied the function will call the marking stage which
 is a modified breadth first search.
 Once the marking stage completes the function runs the trace back algorithm
 and terminates.
 
\end_layout

\begin_layout Subsection
Efficiency and Justification
\end_layout

\begin_layout Paragraph*
Aside from possible micro-optimizations this is the most efficient way to
 find the shortest path between two point on a graph.
 This algorithm has been chosen simply because there is no other algorithm
 to find the shortest path between two points in an unweighted graph.
\end_layout

\begin_layout Paragraph*
Several optimizations have already been added to this implementation.
 The worst case scenario for naive Dijkstra's algorithm occurs when there
 exists no path between the vertices supplied.
 With this implementation if the API gets more than 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 (where 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 is the amount of connected components) requests for nonexistent paths it
 will be more efficient.
 This is because the connected components are counted and marked after the
 entire graph has been recorded.
 The open-queue has also been optimized using a red black tree.
\end_layout

\begin_layout Section
Finding the Shortest Path With Edge Weights
\end_layout

\end_body
\end_document
